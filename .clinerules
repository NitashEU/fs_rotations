# Roo Root Configuration & Style Rules (clinerules) - BASE, PLAIN TEXT INSTRUCTIONS - FINAL, NO MARKDOWN
mode: root # BASE configuration and style rules - PLAIN TEXT INSTRUCTIONS - FINAL, NO MARKDOWN

mode_switching: # Base mode switching configuration - kept at top level as config
  enabled: false
  preserve_context: false

instructions: # OPERATIONAL INSTRUCTIONS AND **ALL STYLE RULES** - **PLAIN TEXT - NO MARKDOWN - FINAL**
  general: # General Instructions for Root mode - List of Strings - **PLAIN TEXT - NO MARKDOWN - FINAL**
    - "You are the Root Configuration and Style Base. All other modes *extend* this, inheriting *all* settings and rules defined in the 'instructions' section. Your role is to provide the project's *complete* and *authoritative* foundation: project context, operational framework, and *every single code style rule* for all modes. Everything Roo needs to know and enforce, project-wide, is defined within *this* 'instructions.general' section below." # Role - EVERYTHING in instructions.general - AUTHORITATIVE - SELF-CONTAINED - PLAIN TEXT
    - "--- PROJECT FOUNDATION ---" # Category: PROJECT FOUNDATION - Separator - PLAIN TEXT
    - "  - Project Context: FS Rotations is a Lua-based system for automated WoW combat rotations designed to... (rest of project context description INLINED here) ..." # Project context - CONTENT INLINED - PLAIN TEXT
    - "  - General Project Guidelines: Always ensure 'repomix-output.txt' is loaded initially... (rest of general guidelines INLINED here) ..." # General guidelines - CONTENT INLINED - PLAIN TEXT
    - "--- BASE STYLE RULES - CODE STYLE & STRUCTURE ---" # Category: CODE STYLE & STRUCTURE RULES - Separator - PLAIN TEXT
    - "  - Rule: Language: Lua is the primary programming language for this project." # Rule: Language - PLAIN TEXT
    - "  - Rule: Modules: Use `require` for module imports. Example: `local spell_helper = require(\"common/utility/spell_helper\")`" # Rule: Modules - PLAIN TEXT
    - "  - Rule: Namespace: ALL plugin code *outside of the `_api` directory* MUST be within the `FS` namespace to prevent global scope pollution and ensure proper encapsulation." # Rule: Namespace - PLAIN TEXT
    - "  - Rule: API Access: Access modules/functions within `_api/` directory using the `FS.api` prefix *only if* they are *explicitly* exposed through `core/api.lua`.  Example: `FS.api.spell_helper:is_spell_queueable(...)`." # Rule: API Access - PLAIN TEXT
    - "  - Rule: Non-Exported API Modules: For modules in `_api/common/` that are *NOT* re-exported by `core/api.lua`, use `require` to import them, creating a *local alias*. Example: `local enums = require(\"common/enums\")`. *Do not* attempt to access these non-exported modules through `FS.api`." # Rule: Non-Exported API Modules - PLAIN TEXT
    - "  - Rule: Top-Level Tables: When defining top-level tables within a module that will be part of the `FS` namespace, explicitly assign them to the `FS` namespace.  Example: `FS.paladin_holy.auras = {}`." # Rule: Top-Level Tables - PLAIN TEXT
    - "  - Rule: Code Organization: Organize code into logical and manageable modules to enhance maintainability and reduce complexity." # Rule: Code Organization - PLAIN TEXT
    - "  - Rule: Programming Paradigm: While Lua supports multiple paradigms, *prefer functional programming* paradigms where appropriate. Avoid Object-Oriented Programming (OOP) and classes unless strictly necessary and justified by design requirements." # Rule: Programming Paradigm - PLAIN TEXT
    - "  - Rule: Modularity & Iteration: Favor iterative development and modular design to minimize code duplication and promote reusable components.  Break down complex functionalities into smaller, testable modules." # Rule: Modularity & Iteration - PLAIN TEXT
    - "--- BASE STYLE RULES - NAMING CONVENTIONS ---" # Category: NAMING CONVENTIONS - Separator - PLAIN TEXT
    - "  - Rule: Naming (Variables & Functions): Use descriptive, snake_case names for all variables and functions to improve code readability and understanding. Example: `get_unit_health`." # Rule: Naming - PLAIN TEXT
    - "  - Rule: Class Naming: If class-like structures are absolutely necessary, use PascalCase for their names. Example: `ObjectPool`." # Rule: Class Naming - PLAIN TEXT
    - "  - Rule: File & Directory Naming: Use snake_case for all file and directory names to maintain consistency across the project. Examples: `health_prediction.lua`, `combat_routines`." # Rule: File & Directory Naming - PLAIN TEXT
    - "  - Rule: Directory Naming: Directories should be named using snake_case (e.g., `combat_routines`)." # Rule: Directory Naming - PLAIN TEXT
    - "  - Rule: File Naming: Files should be named using snake_case with the `.lua` extension (e.g., `target_selection.lua`)." # Rule: File Naming - PLAIN TEXT
    - "  - Rule: Variable and Function Naming: Variables and functions should be named using snake_case (e.g., `calculate_optimal_target`)." # Rule: Variable and Function Naming - PLAIN TEXT
    - "  - Rule: Class-like Structure Naming: Class-like structures (if used) should be named using PascalCase (e.g., `ObjectPool`)." # Rule: Class-like Structure Naming - PLAIN TEXT
    - "  - Rule: Module Exports Naming:  While Lua's module system is flexible, named module exports are *strongly preferred*. Ensure that modules return a table representing their public interface. This promotes explicit API design." # Rule: Module Exports Naming - PLAIN TEXT
    - "--- BASE STYLE RULES - LUA USAGE ---" # Category: LUA USAGE RULES - Separator - PLAIN TEXT
    - "  - Rule: Scope: *Always* use `local` keyword to declare variables unless there is an *extremely* compelling reason for global scope. Global variables should be exceedingly rare in this project and require strong justification." # Rule: Scope - PLAIN TEXT
    - "  - Rule: Imports: Use `require()` for module imports.  Strictly adhere to the rules defined above for accessing module members (using `FS.api` when appropriate, creating local aliases for non-exported API modules)." # Rule: Imports - PLAIN TEXT
    - "  - Rule: Documentation Comments:  Use LuaDoc style comments for documenting functions and complex code logic. *Always* include `@return` annotations for functions, even if the function returns `nil`. Be as specific as possible with type annotations, utilizing custom types (like `game_object`, `vec3`) defined within the `_api/` directory when relevant." # Rule: Documentation Comments - PLAIN TEXT
    - "  - Rule: Variable Name Exceptions: Avoid single-letter variable names in general, *except* for common loop counters (e.g., `i`, `j`, `k`)." # Rule: Variable Name Exceptions - PLAIN TEXT
    - "  - Rule: Explicit Comparisons:  Prefer explicit comparisons for clarity and to avoid potential Lua truthiness pitfalls.  For example, use `if x ~= nil then` instead of relying on implicit boolean coercion like `if x then`." # Rule: Explicit Comparisons - PLAIN TEXT
    - "  - Rule: Boolean Values:  Boolean values in Lua are lowercase: `true` and `false`. Ensure consistency in boolean literal usage." # Rule: Boolean Values - PLAIN TEXT
    - "  - Rule: Explicit 'self' in Methods: Even though Lua allows omitting `self` when calling a method on the *same* object within another method, *always* include `self` explicitly. This enhances code readability and makes method calls clearer, especially for developers less familiar with Lua's implicit `self`." # Rule: Explicit 'self' in Methods - PLAIN TEXT
    - "  - Rule: Table Creation (Pre-allocation): If you have a reasonable estimate of the size a table will grow to, pre-allocate it with `{}` and sufficient initial entries during creation. This can sometimes offer minor performance benefits by reducing re-allocations as the table grows." # Rule: Table Creation (Pre-allocation) - PLAIN TEXT
    - "  - Rule: Avoid `table.insert` in Loops:  Do not use `table.insert(my_table, 1, value)` *inside loops*, especially for performance-sensitive code.  `table.insert` with index `1` is particularly inefficient. Instead, build tables by direct index assignment, appending to the end, or building forward and reversing afterward if needed, or calculate indices directly." # Rule: Avoid `table.insert` in Loops - PLAIN TEXT
    - "  - Rule: Table Iteration:  Use `ipairs()` for iterating over arrays (tables with sequential integer indices) and `pairs()` for iterating over dictionaries (hash-map like tables with arbitrary keys). Use the appropriate iterator for the table structure." # Rule: Table Iteration - PLAIN TEXT
    - "  - Rule: Local Helper Functions: Declare helper functions *within* a module as `local function my_helper() ... end` unless those helper functions are explicitly intended to be part of the module's *public interface*.  This promotes encapsulation and reduces namespace pollution." # Rule: Local Helper Functions - PLAIN TEXT
    - "--- BASE STYLE RULES - ERROR HANDLING ---" # Category: ERROR HANDLING RULES - Separator - PLAIN TEXT
    - "  - Rule: Error Logging:  Use `core.log_error()` (from the provided API) for logging any errors encountered within the plugin. This ensures consistent error reporting and facilitates debugging." # Rule: Error Logging - PLAIN TEXT
    - "  - Rule: Assertions for Critical Errors:  Utilize assertions (`assert()`) for critical conditions that *should never occur* if the code is functioning correctly under normal circumstances. Assertions should primarily indicate programmer errors, not runtime errors that might be gracefully handled. Consider adding `assert` statements to validate function preconditions (e.g., ensuring a `game_object` parameter is not `nil` and is valid before proceeding)." # Rule: Assertions for Critical Errors - PLAIN TEXT
    - "  - Rule: Graceful Handling with `pcall`: Employ `pcall()` to gracefully handle potential runtime errors, particularly when interacting with external systems or APIs (like game API calls) that might be prone to failure. This prevents the entire plugin from crashing due to unexpected errors." # Rule: Graceful Handling with `pcall` - PLAIN TEXT
    - "  - Rule: Contextual Error Messages:  When generating error messages (whether for logging or assertions), include as much contextual information as possible.  This should include relevant variable values, function names, and descriptive details about the error's context to aid in debugging and issue resolution." # Rule: Contextual Error Messages - PLAIN TEXT
    - "--- BASE STYLE RULES - MEMORY MANAGEMENT ---" # Category: MEMORY MANAGEMENT RULES - Separator - PLAIN TEXT
    - "  - Rule: Table Allocation Awareness: Be mindful of table allocations, especially within performance-critical sections of code. Tables in Lua are garbage-collected, but excessive allocation can lead to increased garbage collection overhead and performance degradation. Reuse tables where possible, especially within loops or frequently called functions." # Rule: Table Allocation Awareness - PLAIN TEXT
    - "  - Rule: Table Reuse in Loops: In loops where tables are repeatedly created and discarded in each iteration, strongly consider reusing a single table instance. For example, instead of creating a new `valid_values` table in every loop iteration, create it *once* outside the loop and then clear its contents at the beginning of each iteration." # Rule: Table Reuse in Loops - PLAIN TEXT
    - "  - Rule: Object Pooling (Advanced - Use Judiciously): If object pooling becomes necessary for managing frequently created and destroyed objects (e.g., in very performance-critical simulations or game object handling), discuss the design approach *first* to ensure a consistent and well-justified implementation across the project. If object pooling is used, maintain a consistent style throughout the codebase." # Rule: Object Pooling (Advanced) - PLAIN TEXT
    - "  - Rule: Explicit Garbage Collection (Setting to `nil`): Explicitly set variables to `nil` when they are no longer needed. This is *especially important* for variables referencing tables and userdata objects (like `game_object` instances from the API), as these types of objects consume more memory and benefit most from explicit garbage collection hints. Setting to `nil` allows Lua's garbage collector to reclaim memory more efficiently." # Rule: Explicit Garbage Collection - PLAIN TEXT
    - "--- BASE STYLE RULES - PERFORMANCE OPTIMIZATION ---" # Category: PERFORMANCE OPTIMIZATION RULES - Separator - PLAIN TEXT
    - "  - Rule: Iteration vs. Recursion: In Lua, prefer iteration over recursion where functionally equivalent and performance-critical. Lua does not perform tail-call optimization, so deep recursion can lead to stack overflows and is generally less performant than iterative approaches." # Rule: Iteration vs. Recursion - PLAIN TEXT
    - "  - Rule: Caching Frequently Accessed Values: Implement caching using local variables to store frequently accessed values within a function's scope.  Avoid redundant and repeated lookups in global tables or through API calls, which can be relatively expensive operations. Cache the results of frequently called functions (especially API functions) within a function's scope if the result is used multiple times. Example: Instead of repeatedly calling `FS.variables.enemy_target()`, call it *once* at the beginning of the function and store the result in a local variable for subsequent use." # Rule: Caching Frequently Accessed Values - PLAIN TEXT
    - "  - Rule: Loop Optimizations: Carefully analyze loops for potential performance bottlenecks. Avoid unnecessary calculations or API calls *within* loops that could be moved outside the loop or pre-calculated. Optimize loop conditions and bodies to minimize per-iteration overhead." # Rule: Loop Optimizations - PLAIN TEXT
    - "  - Rule: Profiling for Performance Bottlenecks: Utilize the profiling tools provided in the API (e.g., `core.time()`, `core.cpu_ticks()`) for basic performance profiling. Identify performance-critical sections of code *before* attempting complex optimizations. Premature optimization can be misleading and time-wasting." # Rule: Profiling for Performance Bottlenecks - PLAIN TEXT
    - "  - Rule: String Concatenation Optimization: *Avoid* string concatenation, especially within loops. String concatenation in Lua can be inefficient due to string immutability and repeated allocation. When building strings from fragments, especially in loops, construct a *table* of string fragments and then use `table.concat()` to efficiently join them into a single string at the end. This is significantly more performant than repeated `..` concatenation." # Rule: String Concatenation Optimization - PLAIN TEXT
    - "  - Rule: Metatables for Optimization (Advanced - Use with Extreme Caution): Metatables can offer advanced optimization possibilities in *very specific* and *performance-critical* sections of code (e.g., for highly specialized data structures or operations). However, metatables introduce complexity and can make code harder to understand and debug if overused or improperly applied. Use metatables for optimization *only after thorough profiling* has identified a clear and significant performance bottleneck and *only with extreme caution*.  Document any usage of metatables meticulously and ensure the performance gains justify the added complexity." # Rule: Metatables for Optimization - PLAIN TEXT
    - "--- BASE STYLE RULES - API USAGE ---" # Category: API USAGE RULES - Separator - PLAIN TEXT
    - "  - Rule: API Interaction (Exclusivity): *Strictly* use only the functions and interfaces provided within the `_api/` directory to interact with the game environment. *Never* use any native WoW API functions or interact with game memory directly outside of the provided API. This ensures maintainability, compatibility with the cheat's environment, and prevents potential conflicts or instability." # Rule: API Interaction (Exclusivity) - PLAIN TEXT
    - "  - Rule: API Access Method (FS.api): All interactions with the provided game API *must* be performed through functions and modules exposed in the `_api/` directory, and accessed via the `FS.api` prefix where appropriate (as dictated by the API export rules in `core/api.lua`). This standardizes API access and reinforces the use of the provided API layer." # Rule: API Access Method (FS.api) - PLAIN TEXT
    - "--- BASE STYLE RULES - CODE CONSISTENCY & READABILITY ---" # Category: CODE CONSISTENCY & READABILITY RULES - Separator - PLAIN TEXT
    - "  - Rule: Indentation Consistency: Maintain *consistent indentation* throughout the entire codebase. *Four spaces* are strongly recommended as the standard indentation level. Consistent indentation is critical for code readability and maintainability." # Rule: Indentation Consistency - PLAIN TEXT
    - "  - Rule: Line Length Limits: Keep lines of code reasonably short. A line length of *80-100 characters* is a good general guideline. Shorter lines enhance readability, especially on smaller displays and when code is reviewed or diffed." # Rule: Line Length Limits - PLAIN TEXT
    - "  - Rule: Spacing Conventions:  Apply consistent spacing around operators (e.g., `x = a + b`, not `x=a+b`), after commas in lists and function arguments (e.g., `my_function(arg1, arg2)`), and between function arguments. Consistent spacing significantly improves code visual clarity." # Rule: Spacing Conventions - PLAIN TEXT
    - "  - Rule: Function Grouping in Modules: Within a file or module, logically *group related functions together*. If a file becomes large and contains numerous functions, use comment sections (`-- Section Name --`) to denote different logical groups of functions. This improves code organization and navigation within modules." # Rule: Function Grouping in Modules - PLAIN TEXT
    - "--- BASE STYLE RULES - CONSTANTS ---" # Category: CONSTANTS RULES - Separator - PLAIN TEXT
    - "  - Rule: Constant Definition & Naming:  *Extract constants* to improve code readability and maintainability. Define constants at the *top of files* or within a dedicated `constants.lua` file if project-wide. Use `UPPER_SNAKE_CASE` for naming all constants to clearly distinguish them from variables. Example: `MAX_HEALTH = 100`." # Rule: Constant Definition & Naming - PLAIN TEXT
    - "--- BASE STYLE RULES - GIT USAGE & COMMIT CONVENTIONS ---" # Category: GIT USAGE & COMMIT CONVENTIONS - Separator - PLAIN TEXT
    - "  - Rule: Commit Prefixes (Standardized):  Use the following standardized prefixes for Git commit messages to categorize changes and improve commit log clarity:" # Rule: Commit Prefixes (Standardized) - PLAIN TEXT
    - "    - `fix:` - for commits that address bug fixes." # Prefix: fix: - PLAIN TEXT
    - "    - `feat:` - for commits that introduce new features." # Prefix: feat: - PLAIN TEXT
    - "    - `perf:` - for commits focused on performance improvements." # Prefix: perf: - PLAIN TEXT
    - "    - `docs:` - for commits related to documentation changes." # Prefix: docs: - PLAIN TEXT
    - "    - `style:` - for commits addressing code style issues (formatting, linting)." # Prefix: style: - PLAIN TEXT
    - "    - `refactor:` - for commits that refactor code without adding features or fixing bugs." # Prefix: refactor: - PLAIN TEXT
    - "    - `test:` - for commits related to adding or improving tests." # Prefix: test: - PLAIN TEXT
    - "    - `chore:` - for commits that are general maintenance, build process, or tooling changes." # Prefix: chore: - PLAIN TEXT
    - "  - Rule: Lowercase Commit Messages: Write commit messages in *lowercase*. This contributes to a more uniform and aesthetically cleaner commit history." # Rule: Lowercase Commit Messages - PLAIN TEXT
    - "  - Rule: Concise Commit Summary Line:  Start each commit message with a *concise summary line* that clearly and briefly describes the change. Aim for brevity and clarity in the summary." # Rule: Concise Commit Summary Line - PLAIN TEXT
    - "  - Rule: Descriptive Commit Message Body: For commits that introduce non-trivial changes or require explanation, include a *descriptive body* in the commit message after the summary line. This body should provide additional context, explain the *why* behind the change, and detail any non-obvious aspects of the commit." # Rule: Descriptive Commit Message Body - PLAIN TEXT
    - "  - Rule: Issue/Ticket References in Commits: When a commit addresses or relates to a specific issue or ticket in a tracking system, *reference the issue number* in the commit message. This creates traceability and links code changes to issue tracking." # Rule: Issue/Ticket References in Commits - PLAIN TEXT
    - "--- BASE STYLE RULES - DOCUMENTATION ---" # Category: DOCUMENTATION RULES - Separator - PLAIN TEXT
    - "  - Rule: Documentation Style (LuaDoc):  Utilize LuaDoc style comments for documenting all functions and complex code logic. This standardizes documentation format and enables potential automated documentation generation." # Rule: Documentation Style (LuaDoc) - PLAIN TEXT
    - "  - Rule: Comment Focus & Conciseness: Keep comments concise and focused on *explaining the 'why' and 'how'* of the code, rather than simply restating *'what'* the code does (which should be evident from the code itself). Avoid unnecessary and redundant comments. Favor clarity and brevity." # Rule: Comment Focus & Conciseness - PLAIN TEXT
    - "  - Rule: Module (File) Documentation:  At the top of *every* module (Lua file), include a comment block documenting the *purpose* of the module and its *intended usage*. This provides essential context for understanding the role of each file within the project." # Rule: Module (File) Documentation - PLAIN TEXT
    - "--- OPERATIONAL FRAMEWORK ---" # Category: OPERATIONAL FRAMEWORK - Separator - PLAIN TEXT
    - "  - Base Operational Framework Definition: Establish the base operational framework for all modes. This primarily centers around the Memory Bank system and its usage across modes. Modes will *extend* this base framework with mode-specific behaviors, but the fundamental principles are defined here." # Operational Framework Definition - PLAIN TEXT
    - "  - Task Behavior (Root - Base Configuration): On initialization, the root configuration will establish the project foundation by loading the project context, general guidelines, and *all defined style rules*. It will then perform a validation step to ensure that all other mode configurations are properly set up to *extend* and *consistently follow* these base rules and project standards. The root mode itself remains primarily in an oversight and foundational role, and does not directly perform code implementation or modification tasks (delegating those to specialized modes)." # Root Task Behavior - PLAIN TEXT

  memory_bank: # Memory Bank Instructions for Root mode - List of Strings (if any root-specific MB instructions)
    - "Status Prefix: All modes *implicitly* use '[ROOT CONFIGURATION: ACTIVE/INACTIVE]' status (defined here)." # Reiterate status prefix for all modes - PLAIN TEXT
    - "Behavior: Root defines the *base framework* for Memory Bank usage. Modes extend this framework." # Reiterate root's role in framework definition - PLAIN TEXT