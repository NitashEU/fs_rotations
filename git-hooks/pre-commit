#!/bin/bash

# Get absolute path to repo root
REPO_ROOT="$(git rev-parse --show-toplevel)"

# Debug output
echo "Running pre-commit hook..."
echo "Repo root: $REPO_ROOT"

# Get the current commit message
current_msg_file="$REPO_ROOT/.git/COMMIT_EDITMSG"
if [ -f "$current_msg_file" ]; then
    commit_msg=$(cat "$current_msg_file")
    echo "Using current commit message from COMMIT_EDITMSG"
else
    echo "No commit message found, skipping version bump"
    exit 0
fi

echo "Commit message: $commit_msg"

# Extract commit type from the first line only
commit_type=$(echo "$commit_msg" | head -n 1 | grep -oE '^(feat|fix|perf|docs|style|refactor|test|chore):' | sed 's/://')
echo "Detected commit type: $commit_type"

# Exit if not a versioning commit type
if [[ ! $commit_type =~ ^(feat|fix|perf|refactor)$ ]]; then
    echo "Not a version-bumping commit type, exiting"
    exit 0
fi

# Extract current version from header.lua
current_version=$(grep 'version = ".*"' "$REPO_ROOT/header.lua" | head -n 1 | sed 's/.*version = "\(.*\)".*/\1/')
echo "Current version: $current_version"

# Split version into components
IFS='.' read -r major minor patch <<< "$current_version"

# Determine version bump type based on commit type
if [[ $commit_type == "feat" ]]; then
    new_minor=$((minor + 1))
    new_version="$major.$new_minor.0"
elif [[ $commit_type =~ ^(fix|perf|refactor)$ ]]; then
    new_patch=$((patch + 1))
    new_version="$major.$minor.$new_patch"
else
    exit 0
fi

echo "New version will be: $new_version"

# Update version in header.lua (both occurrences)
sed -i "s/version = \"$current_version\"/version = \"$new_version\"/" "$REPO_ROOT/header.lua"

# Update version in README.md
sed -i "s/Current Version: $current_version/Current Version: $new_version/" "$REPO_ROOT/README.md"

# Add the modified files back to the commit
git add "$REPO_ROOT/header.lua" "$REPO_ROOT/README.md"

echo "Version bumped from $current_version to $new_version based on $commit_type commit"

exit 0